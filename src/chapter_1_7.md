# 图形程序设计和编码

<br/>
&emsp;&emsp;某些常见的策略在图形编程中经常是有用的。在本节中，我们提供了一些建议，当你实现本书所学的方法时，你可能会发现这些建议很有帮助。

## 类型设计
&emsp;&emsp;任何图形程序的一个关键部分是为几何实体（如向量和矩阵）以及图形实体（如RGB颜色和图像）提供良好的类或例程。这些例程应该尽可能的简洁和高效。一个普遍的设计问题是，位置和位移是否应该成为独立的类别，因为它们有不同的操作；例如，一个位置乘以二分之一没有几何意义，而位移的二分之一却有意义（Goldman, 1985; DeRose, 1989）。在这个问题上几乎没有一致的意见，这可能会在图形从业者中引发数小时的激烈争论，但为了举例说明，我们假设不做这种区分。

_我坚信KISS（"保持简单，愚蠢"）原则，从这个角度来看，两个类的论点并不令人信服，不足以证明增加的复杂性。-P.S._

_我喜欢把指针和向量分开，因为它使代码更易读，并能让编译器捕捉到一些错误。-S.M._

&emsp;&emsp;这意味着要编写的一些基本类型包括：
- 一个二维矢量类，用于存储x-和y-分量。它应该将这些分量存储在一个长度为2的数组中，这样就可以很好地支持一个索引操作。你还应该包括矢量加法、矢量减法、点积、交叉积、标量乘法和标量除法的操作。

- 三维向量（vector3）。一个类似于二维向量的三维向量类型。

- h向量（hvector）。一个有四个分量的同质向量（见第8章）。

- rgb。每种RGB颜色存储三个成分。你还应该包括RGB加法、RGB减法、RGB乘法、标量乘法和标量除法的操作。

- 变换。一个用于变换的4×4矩阵。你应该包括一个矩阵乘法和成员函数来应用于位置、方向和表面法向量。如第七章所示，这些都是不同的。

- 图像。一个具有输出操作的RGB像素的二维数组。

_此外，你可能想或不想为时间间隔、正交基和坐标系添加类型。_

_你也可以考虑为单位长度的向量建立一个特殊的类型，尽管我发现它们比价值更痛苦。-P.S._

## 单精度与双精度浮点数（Float vs. Double）

&emsp;&emsp;现代架构表明，减少内存的使用和保持内存访问的连贯性是实现高效的关键。这建议使用单精度数据。然而，为了避免数字问题，建议使用双精度算术。这方面的权衡取决于程序，但在类型的定义中能有一个默认值是很好的。

_我建议在几何计算中使用双精度浮点数，在颜色计算中使用单精度。对于占据大量内存的数据，如三角形网格，我建议存储单精度数据，但当通过成员函数访问数据时，要转换为双精度。-P.S._

## 调试图形程序

&emsp;&emsp;如果你四处打听可能会发现，随着程序员经验的增加，他们越来越少地使用传统的调试器。其中一个原因是，对于复杂的程序来说，使用这样的调试器相比较简单的程序在使用时更加困难。另一个原因是，最严重的错误是概念上的错误，即实现了错误的东西，很容易浪费大量的时间在变量值上，而不能检测到这种情况。我们发现有几种调试策略对图形学特别有用。

_我主张所有的计算都使用单精度浮点数，直到发现在代码的特定部分存在需要双精度的证据。-S.M._

**科学的方法**

&emsp;&emsp;在图形程序中，有一种替代传统调试的方法，往往非常有用。它的缺点在于它与计算机程序员在职业生涯早期被教导不要做的事情非常相似，所以如果你这样做可能会觉得 "很调皮"：我们创建一个图像，观察它有什么问题。然后，我们对导致问题的原因提出一个假设，并对其进行测试。例如，在一个光线追踪程序中，我们可能会有许多看起来有些随机的暗色像素。这是典型的 "阴影痤疮 （shadow acne)"问题，大多数人在编写光线追踪程序时都会遇到。传统的调试在这里是没有用的，相反，我们必须意识到阴影光线是打在被着色的表面上的。我们可能会注意到，黑点的颜色是环境色，所以直接照明是缺失的。直接照明可以在阴影中被关闭，所以你可以假设这些点被错误地标记为在阴影中，而它们不是。为了测试这个假设，我们可以关闭阴影检查并重新编译。这将表明这些是错误的阴影测试，我们可以继续我们的探测工作。这种方法有时可以成为很好的实践的关键原因是，我们从来不需要发现一个错误的值，或者真正明确我们的概念错误。相反，我们只是通过实验缩小了我们的概念性错误。通常情况下，只需要几次试验就可以追踪到事情的真相，这种类型的调试是很愉快的。

**图像作为编码调试的输出**

&emsp;&emsp;在许多情况下，从图形程序中获得调试信息的最简单渠道是输出图像本身。如果你想知道某个变量在每个像素上的部分计算值，你可以临时修改你的程序，把这个值直接复制到输出图像上，而跳过通常要进行的其他计算。例如，如果你怀疑表面法线导致了阴影的问题，你可以直接将法向量复制到图像上（x转为红色，y转为绿色，z转为蓝色），结果就是在计算中实际使用的向量的颜色编码图。或者，如果你怀疑某个特定的值有时超出了它的有效范围，让你的程序在发生这种情况的地方使用鲜红色的像素。其他常见的技巧包括用明显的颜色画出表面的反面（当它们不应该是可见的），用物体的ID数字给图像着色，或者用像素的计算量来着色。

**使用调试器**

&emsp;&emsp;在有些情况下，特别是当科学方法似乎导致了不一致时，观察到底发生了什么是无可替代的。问题是，图形程序往往涉及多次执行相同的代码（例如，每个像素一次，或每个三角形一次），这导致从一开始就在调试器中逐步执行是完全不现实。而且，最困难的错误通常只发生在复杂的输入上。

&emsp;&emsp;一个有用的方法是为这个错误 "设置一个陷阱"。首先，确保你的程序是确定性的--在单线程中运行，并确保所有的随机数都是由固定的种子计算出来的。然后，找出表现出错误的像素或三角形，并在你怀疑不正确的代码前添加一个声明，只对可疑情况执行。例如，如果你发现像素(126, 247)出现了错误，那么就添加
$$
\[
  \begin{aligned}
  &\textbf{if}\ x=126 \ and\ y=247 \ \textbf{then} \\ 
  &\quad \text{print\ ``blarg!"}
  \end{aligned}
\]
$$


_使用固定的随机数种子的特殊调试模式很有用。_

&emsp;&emsp;如果你在打印语句上设置一个断点，你就可以在你感兴趣的像素被计算出来之前进入调试器。有些调试器有一个 "条件断点 "功能，可以在不修改代码的情况下达到同样的效果。

&emsp;&emsp;在程序崩溃的情况下，传统的调试器对于确定崩溃的地点很有用。然后你应该在程序中开始回溯，使用断言和重新编译从而找出程序出错的地方。这些断言应该被留在程序中，以备将来可能出现的错误。这再次意味着要避免传统的一步到位的过程，因为这样就不会在程序中加入有价值的断言。

**调试数据的可视化**

&emsp;&emsp;通常情况下，我们很难理解你的程序在做什么，因为它在最终出错之前计算了大量的中间结果。这种情况类似于测量大量数据的科学实验，有一个解决办法是一样的：为自己制作好的图表和插图以了解数据的含义。例如，在光线追踪器中，你可能会编写用于将光线树可视化的代码，这样你就可以看到哪些路径对一个像素的贡献，或者在图像重采样程序中，你可能会做一些图来显示所有从输入中提取样本的点。花费时间编写代码来可视化程序的内部状态，也将在你优化它的时候，通过更好地理解它的行为作为回报。
_我喜欢把调试打印的语句格式化，这样输出的结果恰好是一个MATLAB！或Gnuplot脚本，可以做出有帮助的图。-S.M._

### 说明

&emsp;&emsp;关于软件工程的讨论受到Effective C++系列（Meyers, 1995, 1997）、极限编程运动（Beck & An-dres, 2004）和The Practice of Programming（Kernighan & Pike, 1999）的影响。关于实验性调试的讨论是基于与Steve Parker的讨论。

&emsp;&emsp;有许多与计算机图形学有关的年度会议，包括ACM SIGGRAPH和SIGGRAPH Asia、Graphics Interface、Game Developers Conference（GDC）、Eurographics、Pacific Graphics、High Performance Graphics、Eurographics Symposium on Rendering以及IEEE VisWeek。通过网络搜索，可以很容易找到这些会议的名称。